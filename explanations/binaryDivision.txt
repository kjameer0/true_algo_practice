 i just tried to understand more about how binary operations and bitwise operations work. what i learned about bitwise operations is that they alwways are o of 1 time complexity because they are bound by the fact that JS bitwise operations take place with 32 bit signed integers. the problem that I am having pertains to the problem of binary division. in this problem, the prompt contains a section wherein it states that the quotient of the two given numbers should not exceed 2 to the 31st power in magnitude, positive or negative. You feel me? As a result, going off of that, therefore, in essence, you get what's coming, check this out harlot, if i calculate a quotient i have to then check if that quotient is within the bounds. the problem there is that i dont know if im converting a number that is greater than the bounds or not. So i cant help but think i need a new way to engage with this problem. ok lemme see, maybe i could check at the beginning if either number is greater than 2 to the 31st power, because if that were so... what? what do i get outta that, do i get shit? probably not? why? the reason why might be that even if i know the number is greater than the bound in magnitude doesnt mean ill know if the quotient will be. i need a way to convert the number to binary and then do my division and finally check the length of the string at the end. here's the issue though, that seems way too complicated. how can i know that a quotient will be greater than the bounds of the problem before i go into it? i could convert it to binary and then convert it back when immediately, and if the numbers are not equal i know its too much. thats cap though because i could also do that by just comparing it to max value. yeah the number could be like 50 9's divided by 2, or 50 9's dividied by 49 9's. the difference between those two examples is that one of them is greater than the bounds, the quotient  that is, and one of them is not, you feel? so i think what i should do is just convert it to a binary string, do my division, and check the length of the answer, if the answer is greater than 32 in length then fuck it, ill just return the max value. but wait, i dont even know what to do in the long run, like i still have to check if a number is negative or not right, and if it is negative then the first integer will be 1, but i cant do that if the integer might be too long right? im so lost in the sauce. how do i handle the idea of the number being too big? it feels like i cant handle it like im missing some core idea here about the size of numbers. numbers in js can be up to a certain value before they are represented by bigint right? any number that is smaller than that is bing chilling and can be operated on normally, my issue is that this idea of a number being greater than the value achievable by a 32 bit signed integer is not good. its not bussin at all. its so unfurtunate and hurtful, what i=am i supposed to do with this scary and frigthening and skin crawling information. i have no choice but to relinquise my role in my family and abandon my children. im sorry rahm, sandrapreet, your father has to abandon you because he could figure out what to do with big int values. idk how to gelp myself in this situation like goddamn, okay well what are my options. my options are to maybe convert every digit to binary in the actual number and do the calculations that way. like im im breaking apart 30 into 3 groups, so 30 /3, i have a 0 in the tens place for 3 and i convert each digit to binary, then i do binary division on each of the digits, but the problem is 9 in  binary is three digits, also im basically doing that anyway. hold on wait im getting something. look at each digit in the no wait never mind, i cant get over the ramifications of moving between decimal and binary at the beginning of the problem. if i didnt have to deal with the edge case of the quotient being greater than 2 to the 31st, then i would be fine. i would look at the divisior and check the first digit once converted to binary andkeep checking if the dividend will fit into the divisor and then subtract the two values accordingly, you feel? but because i cant properly make negative numbers, wait whould this work completely if i didnt have to deal with negative numbers, yeah actually it might. if im only dealing with postive numbers, i can do my original plan of converting the big ass number to fucking binary and then running with that juicy shit. just do my division algorithm on that and then if that magnitude is too great length wise then check if one or both of the integers are negative and return negative max value. if its not too greate than return the two's complement if they're negative, the quotient that is. so i think i got it. just keep checking the problem for the presence of a negative number, no scartch that, treat both as positive numbers, do my long division, and if my long division yields a length too big then return max value, otherwise return the number back in decimal if its negative or convert to two's complement and convert to decimal if its negative


problem;
1. its it time complexity issue to convert between
