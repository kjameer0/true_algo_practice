let grid = [
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "0",
    "1",
    "1",
  ],
  [
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
  ],
  [
    "1",
    "0",
    "1",
    "1",
    "1",
    "0",
    "0",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "0",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
  ],
  [
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "0",
    "1",
    "1",
    "1",
    "1",
    "0",
    "0",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
  [
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
    "1",
  ],
];
class Queue {
  constructor() {
    this.q = {};
    this.size = 0;
    this.tail = null;
  }
  size() {
    return this.size;
  }
  isEmpty() {
    return this.size === 0;
  }
  peek() {
    return this.q.val;
  }
  enqueue(val) {
    const node = {
      val: val,
      next: null,
    };
    if (this.tail) {
      this.tail.next = node;
      this.tail = this.tail.next;
    } else {
      this.q = node;
      this.tail = node;
    }
    this.size++;
  }
  dequeue() {
    if (this.size === 0) throw new Error("queue empty");
    const node = this.q.val;
    this.q = this.q.next;
    this.size--;
    if (this.size === 0) {
      this.tail = null;
    }
    return node;
  }
}
console.log(grid.length);
console.log(grid[0].length);
var numIslands = function (grid) {
  const WATER = "0",
    LAND = "1";
  const DIRECTIONS = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0],
  ];
  let count = 0,
    rows = grid.length - 1,
    cols = grid[0].length - 1;
  function bfs(grid, r, c) {
    // when a 1 is found
    const queue = new Queue();
    queue.enqueue([r, c]); //get initial node in queue
    grid[r][c] = WATER; //mark it as seen
    while (queue.size()) {
      let size = queue.size();
      for (let i = 0; i < size; i++) {
        //get every node in the queue
        let [row, col] = queue.dequeue();
        for (let [x, y] of DIRECTIONS) {
          let iRow = row + x;
          let iCol = col + y;
          if (
            // check if new direction is valid
            iRow < 0 ||
            iRow > rows ||
            iCol < 0 ||
            iCol > cols ||
            grid[iRow][iCol] !== LAND
          )
            continue;
          grid[iRow][iCol] = WATER;
          queue.enqueue([iRow, iCol]); //queue up next node if it exists
        }
      }
    }
  }
  for (let i = 0; i <= rows; i++) {
    //look through every grid position
    for (let j = 0; j <= cols; j++) {
      if (grid[i][j] === "0") continue;
      count++;
      bfs(grid, i, j);
    }
  }
  return count;
};
